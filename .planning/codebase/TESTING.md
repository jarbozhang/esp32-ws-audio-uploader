# Testing Patterns

**Analysis Date:** 2026-02-02

## Test Framework

**Runner:**
- No testing framework detected
- Arduino/PlatformIO projects typically use platform-specific testing (e.g., PlatformIO Unit Testing)
- Current project: MVP stage with no test infrastructure configured

**Assertion Library:**
- Not applicable

**Run Commands:**
```bash
# Current testing approach: manual validation via Serial output
# To add unit tests with PlatformIO:
pio test                # Run all tests
pio test --environment esp32-s3  # Run tests for specific environment
```

**Configuration File:**
- No `platformio.ini` test configuration found
- To add testing: create `test/` directory and configure `platformio.ini`

## Test File Organization

**Current Status:**
- No test files present
- Single-file architecture: `src/main.cpp`
- Suitable for adding tests in dedicated `test/` directory

**Recommended Location:**
- `test/test_*.cpp` - Unit test files following PlatformIO convention
- `test/` directory at project root level

**Naming Convention:**
```
test/test_websocket.cpp
test/test_wifi_connection.cpp
test/test_message_format.cpp
```

## Test Structure

**Proposed Pattern for Arduino Unit Tests:**

```cpp
#include <Arduino.h>
#include <unity.h>

// Test setup
void setUp(void) {
  // Before each test
}

// Test teardown
void tearDown(void) {
  // After each test
}

// Test cases
void test_message_format(void) {
  TEST_ASSERT_EQUAL(expected, actual);
}

// Main test runner (auto-generated by PlatformIO)
void runUnityTests(void) {
  UNITY_BEGIN();
  RUN_TEST(test_message_format);
  UNITY_END();
}

void setup() {
  runUnityTests();
}

void loop() {}
```

**Patterns Observed in Current Code:**
- Event-driven architecture: difficult to unit test without mocking WebSocket library
- Global state (`WebSocketsClient ws`, `String reqId`): requires test isolation
- Callback-based design: testing requires injecting mock callbacks

## Mocking

**Framework:**
- Arduino testing typically uses direct hardware mocking or dependency injection
- No mocking library detected in current configuration

**Recommended Approach:**
```cpp
// Mock WebSocket client for testing
class MockWebSocketsClient {
  String lastMessage;
  void sendTXT(String msg) {
    lastMessage = msg;
  }
  String getLastMessage() {
    return lastMessage;
  }
};

// Inject into production code via interfaces or templates
```

**What to Mock:**
- `WebSocketsClient` - Third-party library dependency
- WiFi connections - Hardware dependency
- Serial output - For capturing logging in tests

**What NOT to Mock:**
- JSON message format generation - Core logic to verify
- State machine logic (connect → start → stream → end → disconnect)
- Audio parameter configuration

## Fixtures and Test Data

**Test Data Pattern:**
```cpp
const char* TEST_WIFI_SSID = "TEST_WIFI";
const char* TEST_WIFI_PASS = "test_password";
const char* TEST_AUTH_TOKEN = "test_token_123";
const char* TEST_REQ_ID = "test-req-1";

String getExpectedStartMessage() {
  return String("{\"type\":\"start\",\"token\":\"") + TEST_AUTH_TOKEN +
         "\",\"reqId\":\"" + TEST_REQ_ID + "\",...}";
}
```

**Location:**
- `test/fixtures/` for shared test data
- Constants at top of test files for isolated test suites

## Coverage

**Requirements:**
- No coverage enforcement configured
- Recommended minimum: Core WebSocket message generation (100%)
- State machine transitions (>80%)

**View Coverage:**
```bash
pio test --verbose  # Shows test output but not coverage metrics
# For coverage reporting, configure with coverage tools in platformio.ini
```

## Test Types

**Unit Tests:**
- Scope: Individual functions like `sendStart()`, `sendEnd()`
- Approach: Mock WebSocket client, verify message format and structure
- Example: Test that `sendStart()` generates correct JSON with all required fields

**Integration Tests:**
- Scope: WebSocket communication flow (connect → start → end)
- Approach: Mock WebSocket library callbacks, verify state transitions
- Example: Test that receiving `WStype_CONNECTED` triggers `sendStart()`

**Hardware Integration Tests:**
- Scope: WiFi connection, I2S audio recording (when implemented)
- Approach: Run on actual ESP32-S3 hardware
- Test commands: `pio run -t upload && pio device monitor`

**E2E Tests:**
- Framework: Not currently used
- Recommended: Manual testing with actual WebSocket server (specified in README.md)
- Could implement with device emulation/simulation once core logic complete

## Validation Without Tests (Current MVP Pattern)

**Manual Verification:**
- Serial output monitoring via `pio device monitor` at 115200 baud
- WebSocket server response validation (manual inspection of server logs)
- Message format validation via server-side parsing (implicit in server acceptance)

**Observed Testing Approach:**
- Debug output via `Serial.println()` and `Serial.printf()` showing:
  - WiFi connection status
  - WebSocket connection/disconnection events
  - Received message content and binary data length

## Recommended Testing Strategy (Next Phase)

**Phase 1 - Unit Testing:**
1. Create `test/test_messages.cpp` with message format validation
2. Mock WebSocket client to capture sent messages
3. Verify JSON structure, field types, required parameters

**Phase 2 - Integration Testing:**
1. Create `test/test_protocol.cpp` with state machine tests
2. Simulate WebSocket events in sequence
3. Verify correct message send order (start → chunks → end)

**Phase 3 - Hardware Testing:**
1. Add I2S audio recording implementation
2. Test audio buffer filling and frame transmission
3. Validate audio data format (16kHz, 16-bit mono)

---

*Testing analysis: 2026-02-02*
